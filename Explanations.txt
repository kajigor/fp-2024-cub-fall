------------------------------------------------------------------------------------------
My project is a Minesweeper game. First, to properly remind myself of the gameplay of Minesweeper
and to understand what the key elements of the game are I played a couple of versions of the game on my phone. 
In my opinion the key elements of a Minesweeper are:
1. A Game Grid - grid with cells that either contain a mine, empty, or adjacent to mines
2. Mine placement - random distribution of mines across the grid
3. Revealing Cells - a number, a mine, or recursively reveal surrounding cells
4. Win/Loss conditions - all non-mines revealed/a mine revealed
6. Input Handling - player input for the cell to be revealed. Allow flagging
7. Timer - is present in most of the versions of the game i have tried.

Also need to add Unit and Property-based tests unique to the Haskell implementaton of the game.

------------------------------------------------------------------------------------------

First, I setup a project. I decided to use stack, as we have been primarily using it for Homework Assignments.
Named the project Minesweeper. From the beginning, to follow modular programming and seperation of concerns 
principles I have decided to Each module is designed to handle a specific part of the gameâ€™s functionality, 
ensuring high cohesion and low coupling. This approach makes the code easier to understand, test, and maintain.
For example, the Grid module focuses solely on grid-related operations. Moved Main.hs into app folder to seperate
the entry point of the program from the library code (src/...)

------------------------------------------------------------------------------------------

Second, I started working on the Game Grid. First I made a new Algebraic Data Type (ADT) 
for cells. It has only one constructor with multiple fields. Each field corresponds to
possible contents of the cell. A cell can either have a revealed mine, a revealed cell
with a number of adjacent mines, a flagged cell, or an unrevealed cell.

----------------------------------------------------------------------
Next worked on random generation of grids. Explanations behind certain choices made are in the comments

randomUniqueIndices :: Int -> Int -> IO [Int]
randomUniqueIndices n maxIndex = do
  -- replicateM to repeat a monadic action multiple times and collect results in a list
  indices <- replicateM n (randomRIO (0, maxIndex - 1))
  -- nub to remove duplicating indices
  return $ take n (nub indices)

wanted to do this, but then if indices are duplicated and removed due to nub there would be less than n mines
Instead used Sets since they already handle the duplicates.

-------------------------------------------------------------------------------------------------

Third, Revealing cells.

When designing the revealCell function, I focused on implementing the cascading reveal,
 where empty cells with no adjacent mines recursively reveal their neighbors until all connected 
 empty regions are uncovered. I chose recursion for this because it naturally reflects the depth-first 
 behavior of revealing cells in Minesweeper. Using foldl, I applied the revealCell function to all valid neighbors, 
 progressively updating the grid without mutating state, making the cascading process both intuitive and efficient.

----------------------------------------------------------------------------------------------------
First playable version ready. 

After playing for a bit found a lot of issues.
One of them was that I forgot to take into account that the first move that the player makes should never turn out to be a mine.
What i did instead is have player input the grid data, but then at first he is given an empty grid but it is not visible.
After he chooses the first field the random grid is generated and replaces the previous empty one.

I also then added flagging. Modified the game logic quite a bit a couple of times. At first I asked for a row and column
in seperate inputs, but I think it is less convenient than doing it in a single line.

Also to improve modularity I moved the game logic from main into a new Game module.

Asking for the first move is more unique to the rest of the inputs that will take place because you don't need to flag.

Grid.hs file became too packed. It contained the Grid type, functions for Grid rendering, generation, flagging, revealing cells, etc.
Created a Grid folder and seperated Grid.hs into 3 modules.

Another thing that I started to consider was that choosing the cell to reveal by looking at the grid in the terminal
is pretty inconvenient the way it is right now. In the phone version you tap on the cell you want to reveal, while here
you enter the row and the column. So having to count which row and column the cell is in everytime is annoying. Also
the fact that indexing starts from 0.
I have decided to try and box the entire grid and then add indexing around that box.

I modified my function for rendering grids to make it look like a grid / matrix with indeces on top and the left.
Previously render function looked as follows:

-- Render the grid as a string for display in the console
renderGrid :: Grid -> IO ()
renderGrid = mapM_ (putStrLn . renderRow)
  where
    renderRow = concatMap renderCell
    renderCell cell
        | isRevealed cell && isMine cell  = "* "  -- Revealed mine
        | isRevealed cell                 = show (adjacentMines cell) ++ " "
        | isFlagged cell                  = "F "  -- Flagged cell
        | otherwise                       = ". "  -- Unrevealed cell

Tried to move as much game code from Main into Game.hs. Also created a lot of additional helper functions because there
was repetitive code in the Game logic.

----------------------------------------------------------------------------------------------------

Changes after feedback. Indeed as one of the examples that Professor ran, the game hangs on certain inputs.

I fixed this by ensuring that each recursive call receives the most up-to-date version of the grid. 
Instead of using foldl, I wrote a helper function that explicitly passes the updated grid to each recursive call.

Nvm that didn't solve it.

It looks like the issue is that the getNeighborCoords function includes the current cell itself as one of its neighbors.
By updating the getNeighborCoords function to exclude the current cell from its neighbors, 
I prevent infinite recursion caused by the cell repeatedly processing itself. 

Didn't resolve it.

------------------------------------------------------------------------------------------------------------------------------------------------
Moved my attention to other fixes 
Resolved the minor mistakes indicated by professor.

Using lists for the grid representation is causing a performance lag, especially with larger dimensions. 
The time complexity for many operations on lists (like accessing an element, appending, or updating) is higher compared 
to other data structures like Array or Vector, so I decided to switch to array.

I have decided to switch to Vector. Had to change functions in every file in some places, but the overall logic for each
is mostly the same.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Went back to solving the previous issue with a grid with 1,3,1 parameters and 0,1 as input.
Finally understood the issue.

When running the Minesweeper game with the input dimensions 1x3 and 1 mine, the game appeared to hang after the first move (0,1). 
Debugging revealed that the function responsible for generating the random grid (generateRandomGrid) 
entered an infinite loop while trying to place mines.

In a Minesweeper game, the first move guarantees that the cell selected and its immediate neighbors will not contain mines. 
For a 1x3 grid, selecting the middle cell (0,1) excludes all cells ([1,0,2]) from mine placement. 
However, the game was still attempting to place 1 mine in a grid where no valid cells remained, 
leading to an infinite loop as the program kept retrying to find valid positions for mines.

Solved the issue.  Before attempting to generate a grid, we calculate the number of valid cells (i.e., total cells minus excluded cells). 
If the number of requested mines exceeds the number of valid cells, an error is raised, preventing the game from proceeding.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Two additional comments from Professor:
There's nothing wrong with placing a mine in every cell ðŸ¥²
Well... The version of a minesweeper game I had in my childhood allowed the user to blow up at the first move.

My version of the game is based on the modern version and I wouldn't want my users to quit after the first turn haha.